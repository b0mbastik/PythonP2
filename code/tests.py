import unittest, io, sys, time, os
import data_refinement as dr, refined_graphs as rg, groupTable as gt, matplotlib.image as mpimg,  matplotlib.pyplot as plt 

class TestRefinedData(unittest.TestCase):
    def setUp(self):
        self.df = dr.read_data('../data/refined_census2011.csv')
        self.vf = dr.read_data('../data/census_variables.csv')

    """
    Checks that the read_data function can read a csv file, and raises a FileNotFoundError when the file cannot be found
    """
    def test_read_data(self):
        self.assertTrue(self.df.compare(dr.read_data('../data/refined_census2011.csv')).empty)
        self.assertRaises(FileNotFoundError, dr.read_data, '../data/census2010.csv')

    """
    Checks a refined dataset can be created using read_data on a csv file
    """
    def test_refine_dataset(self):
        df = dr.read_data('../data/census2011.csv')
        self.assertTrue(self.df.compare(dr.refine_dataset(df)).empty)

    """
    Checks that the refined census can be saved 
    """
    def test_save_refined_data(self):
        dr.save_refined_data(self.df, '../data/refined_testData.csv')
        self.assertTrue(self.df.compare(dr.read_data('../data/refined_testData.csv')).empty)
        os.remove('../data/refined_testData.csv')

    """
    Checks that the get_sorted_columns function returns a valid tuple containing the sorted value counts of the data
    in a given variable, and the names for each value taken by the variable represented textually
    Also checks a ValueError is raised when given invalid data
    """
    def test_get_sorted_columns(self):
        vc = self.df.Region.value_counts().sort_index()
        tup = rg.get_sorted_columns(self.df.Region, self.vf.Region)
        self.assertTrue(vc.compare(tup[0]).empty)
        self.assertTrue(self.vf.Region.dropna().compare(tup[1]).empty)
        self.assertRaises(ValueError, rg.get_sorted_columns, self.df.Region, self.vf.Industry)
        self.assertRaises(ValueError, rg.get_sorted_columns, self.df.Industry, self.vf.Region)

    """
    Checks that the getTable function is able to generate a valid groupby graph when given correct dataframe variables for the data
    of a variable and the names for each value taken by the variable represented textually
    Also checks a ValueError is raised when invalid variables are provided to getTable
    """
    def test_getTable(self):
        dt = gt.getTable(self.df, self.vf, "Occupation", "Approximated Social Grade")
        self.assertEqual(dt.columns.tolist(), self.vf["Approximated Social Grade"].dropna().values.tolist())
        self.assertEqual(dt.index.tolist() , self.vf["Occupation"].dropna().values.tolist())
        self.assertRaises(ValueError, gt.getTable, self.df, self.vf, "Not a variable", "Approximated Social Grade")
        self.assertRaises(ValueError, gt.getTable, self.df, self.vf, "Occupation", "Social Grade")

    """
    Checks that the data contained in the group table matches the data in the pandas dataframe
    Compares the number of region records for each region with the same data in the groupby table
    Compares the number of industry records for each industry with the same data in the groupby table
    """
    def test_groupTable_data(self):
        dt = gt.getTable(self.df, self.vf, "Region", "Industry")
        rt = self.df.Region.value_counts().sort_index()
        for i, j in zip(dt.index, rt):
            self.assertEqual(dt.loc[i].sum(), j)
    
        it = self.df.Industry.value_counts().sort_index()
        for c, d in zip(dt.columns, it):
            self.assertEqual(dt[c].sum(), d)

    """
    Checks that the data contained in df (refined census) and vf (census variables) match up
    vf should not contain an entry for person ID, so there should be one less row in the table
    """
    def test_df_and_vf_match(self):
        self.assertEqual((self.df.columns.size-1), self.vf.columns.size)
        with open("../data/expected_columns.txt") as excpt:
            expected = excpt.read()
            excpt.close()

        for c, d in zip(self.df.columns, expected.splitlines()):
             self.assertEqual(c, d)
             if (c != "Person ID"):
                  self.assertIsNotNone(self.vf.get(c))
    
    """
    Checks that images are generated by get_bar_chart, get_pie_chart, and get_table_3d_chart 
    """

    def test_image_generation(self):
        try:
             os.remove('../images/age_pie.png')
             os.remove('../images/region_bar_chart.png')
             os.remove('../images/region_and_industry_3D_bar_chart.png')
        except:
             pass

    
        rg.get_bar_chart(self.df.Region, self.vf.Region, "Region", "Number of records", "Number of records per region", "../images/region_bar_chart.png")
        rg.get_pie_chart(self.df.Age, self.vf.Age, "Age Distribution", "Ages", "../images/age_pie.png")
             
        dt = gt.getTable(self.df, self.vf, "Region", "Industry")
        rg.get_table_3d_chart(dt, "Region", "Industry", "Number of records", 20, 20, "../images/region_and_industry_3D_bar_chart.png")
    
        mpimg.imread("../images/region_bar_chart.png")
        mpimg.imread("../images/age_pie.png")
        mpimg.imread("../images/region_and_industry_3D_bar_chart.png")
    
        self.assertRaises(FileNotFoundError, mpimg.imread, "../images/region_bar_chat.png")
        self.assertRaises(FileNotFoundError, mpimg.imread, "../images/ae_pie.png")
        self.assertRaises(FileNotFoundError, mpimg.imread, "../images/region_and_industry_3D_bar_chat.png")

        os.remove('../images/age_pie.png')
        os.remove('../images/region_bar_chart.png')
        os.remove('../images/region_and_industry_3D_bar_chart.png')
        